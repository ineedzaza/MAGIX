<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ImageFX — HTML Example</title>
  <style>
    :root{--gap:10px;--panel-w:360px}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0;background:#111;color:#eee;display:flex;height:100vh}
    .sidebar{width:var(--panel-w);padding:16px;box-sizing:border-box;overflow:auto;background:#0f1113;border-right:1px solid rgba(255,255,255,0.04)}
    main{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;gap:12px}
    h1{font-size:18px;margin:0 0 8px}
    label{display:block;margin:6px 0;font-size:13px}
    input[type=file]{display:block}
    .canvas-wrap{background:#222;padding:12px;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    canvas{max-width:100%;height:auto;display:block}
    .controls{display:flex;flex-direction:column;gap:8px}
    .effect{border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
    .effect h3{font-size:13px;margin:0 0 6px}
    .row{display:flex;gap:8px;align-items:center}
    .row > *{flex:1}
    select,input[type=range]{width:100%}
    button{background:#1f6feb;color:white;border:0;padding:8px 10px;border-radius:6px;cursor:pointer}
    .small{font-size:12px;padding:6px}
    .stack{margin-top:10px}
    .stack .stack-item{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:6px;background:#0b0c0d;margin-bottom:6px}
    .stack .stack-item button{background:transparent;color:#9aa; border:1px solid rgba(255,255,255,0.03);padding:6px;border-radius:6px}
    .footer{display:flex;gap:8px;margin-top:12px}
    .hint{font-size:12px;color:#9aa;margin-top:8px}
    input[type=color]{height:36px;padding:0;border:0;background:none}
  </style>
</head>
<body>
  <aside class="sidebar">
    <h1>ImageFX — Example</h1>

    <div class="controls">
      <label>Upload image
        <input id="file" type="file" accept="image/*">
      </label>

      <div class="row">
        <button id="reset" class="small">Reset</button>
        <button id="export" class="small">Export PNG</button>
      </div>

      <div class="hint">Add effects from the list, tweak parameters, then Export. Effects are applied in stack order (top → bottom).</div>

      <label>Choose effect to add
        <select id="effect-select">
          <option value="channel">Color Channel Mixer</option>
          <option value="hsl">HSL Adjust</option>
          <option value="lab">LAB Adjust (approx)</option>
          <option value="invert">Invert (luminosity)</option>
          <option value="overlay">Overlay Color + Blend</option>
          <option value="fisheye">Fisheye</option>
          <option value="kaleido">Kaleido</option>
          <option value="mirror">Mirror</option>
          <option value="swirl">Swirl</option>
          <option value="waves">Waves</option>
        </select>
      </label>
      <div class="row"><button id="add-effect">Add Effect</button><button id="remove-last">Remove Last</button></div>

      <div class="stack" id="stack"></div>
    </div>
  </aside>

  <main>
    <div class="canvas-wrap">
      <canvas id="canvas" width="1024" height="768"></canvas>
    </div>
    <div class="footer">
      <button id="apply" class="small">Apply Stack</button>
      <button id="preview" class="small">Preview (fast)</button>
      <button id="fit" class="small">Fit to Canvas</button>
    </div>
  </main>

  <script>
  // ======= Basic app structure ========
  const fileEl = document.getElementById('file');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const effectSelect = document.getElementById('effect-select');
  const addBtn = document.getElementById('add-effect');
  const stackEl = document.getElementById('stack');
  const applyBtn = document.getElementById('apply');
  const previewBtn = document.getElementById('preview');
  const exportBtn = document.getElementById('export');
  const resetBtn = document.getElementById('reset');
  const removeLastBtn = document.getElementById('remove-last');
  const fitBtn = document.getElementById('fit');

  let baseImage = null; // Image object
  let baseImageData = null; // original image data for re-processing
  let effectStack = [];

  // ===== helper utils =====
  function clamp(v, a, b){return Math.max(a, Math.min(b, v));}
  function applyToCopy(fn, width, height){
    const src = ctx.getImageData(0,0,width,height);
    const dst = ctx.createImageData(width,height);
    fn(src, dst);
    ctx.putImageData(dst,0,0);
  }

  // load file
  fileEl.addEventListener('change', async e=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{
      baseImage = img;
      fitToCanvas();
      drawBase();
    };
    img.src = url;
  });

  function fitToCanvas(){
    if(!baseImage) return;
    const maxW = Math.max(600, window.innerWidth - 420);
    const ratio = baseImage.width/baseImage.height;
    canvas.width = Math.min(baseImage.width, maxW);
    canvas.height = Math.round(canvas.width/ratio);
  }
  fitBtn.onclick = ()=>{fitToCanvas(); if(baseImage) drawBase();}

  function drawBase(){
    if(!baseImage) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(baseImage, 0, 0, canvas.width, canvas.height);
    baseImageData = ctx.getImageData(0,0,canvas.width,canvas.height);
  }

  resetBtn.onclick = ()=>{ effectStack = []; renderStackUI(); if(baseImage) drawBase(); }

  exportBtn.addEventListener('click', ()=>{
    const data = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.download = 'imagefx-export.png';
    a.href = data;
    a.click();
  });

  removeLastBtn.onclick = ()=>{ effectStack.pop(); renderStackUI(); }

  // ====== Effect factory & UI ======
  function addEffect(type, opts){
    const e = {type, opts: opts || defaultOptionsFor(type)};
    effectStack.push(e);
    renderStackUI();
  }

  function defaultOptionsFor(type){
    switch(type){
      case 'channel': return {r:1,g:1,b:1,a:1};
      case 'hsl': return {h:0,s:0,l:0};
      case 'lab': return {L:0,a:0,b:0};
      case 'invert': return {enabled:true};
      case 'overlay': return {color:'#000000',blend:'normal',alpha:1};
      case 'fisheye': return {strength:0};
      case 'kaleido': return {slices:6,angle:0,centerX:0.5,centerY:0.5,mirror:true};
      case 'mirror': return {angle:0,centerX:0.5,centerY:0.5};
      case 'swirl': return {angle:0,centerX:0.5,centerY:0.5};
      case 'waves': return {horizontal:0,vertical:0,ampH:0,ampV:0};
      default: return {};
    }
  }

  addBtn.addEventListener('click', ()=>{ addEffect(effectSelect.value); });

  function renderStackUI(){
    stackEl.innerHTML = '';
    effectStack.forEach((e,i)=>{
      const div = document.createElement('div'); div.className='stack-item';
      const left = document.createElement('div'); left.style.flex='1';
      const title = document.createElement('div'); title.textContent = `${i+1}. ${e.type}`; title.style.fontSize='13px';
      left.appendChild(title);
      const btns = document.createElement('div');
      const edit = document.createElement('button'); edit.textContent='Edit';
      edit.onclick = ()=>{ openEditor(i); };
      const up = document.createElement('button'); up.textContent='▲'; up.onclick=()=>{ if(i>0){ effectStack.splice(i-1,2,e, effectStack[i-1]); renderStackUI(); }};
      const down = document.createElement('button'); down.textContent='▼'; down.onclick=()=>{ if(i<effectStack.length-1){ effectStack.splice(i,2,effectStack[i+1],e); renderStackUI(); }};
      const del = document.createElement('button'); del.textContent='✕'; del.onclick=()=>{ effectStack.splice(i,1); renderStackUI(); };
      [edit, up, down, del].forEach(b=>{ b.style.marginLeft='6px'; btns.appendChild(b) });
      div.appendChild(left); div.appendChild(btns);
      stackEl.appendChild(div);
    });
  }

  function openEditor(index){
    const e = effectStack[index];
    // simple modal-like small inline editor
    const modal = document.createElement('div'); modal.className='effect';
    const h3 = document.createElement('h3'); h3.textContent = `Edit ${e.type}`; modal.appendChild(h3);

    const form = document.createElement('div');

    function addRange(name, min, max, step){
      const label = document.createElement('label'); label.textContent = name;
      const input = document.createElement('input'); input.type='range'; input.min=min; input.max=max; input.step=step; input.value = e.opts[name] ?? 0;
      const val = document.createElement('div'); val.style.fontSize='12px'; val.textContent = input.value;
      input.oninput = ()=>{ e.opts[name] = parseFloat(input.value); val.textContent = input.value; };
      label.appendChild(input); label.appendChild(val); form.appendChild(label);
    }

    function addNumber(name, min, max, step){
      const label = document.createElement('label'); label.textContent = name;
      const input = document.createElement('input'); input.type='number'; input.min=min; input.max=max; input.step=step; input.value = e.opts[name] ?? 0;
      input.oninput = ()=>{ e.opts[name] = parseFloat(input.value); };
      label.appendChild(input); form.appendChild(label);
    }

    switch(e.type){
      case 'channel':
        addRange('r',0,1,0.01); addRange('g',0,1,0.01); addRange('b',0,1,0.01); addRange('a',0,1,0.01);
        break;
      case 'hsl':
        addRange('h',-360,360,1); addRange('s',-100,100,1); addRange('l',-1,1,0.01);
        break;
      case 'lab':
        addRange('L',-100,100,1); addRange('a',-2,2,0.01); addRange('b',-2,2,0.01);
        break;
      case 'invert':
        const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = e.opts.enabled ?? true; chk.onchange=()=>{ e.opts.enabled = chk.checked; }; form.appendChild(chk); form.appendChild(document.createTextNode('Enable inversion'));
        break;
      case 'overlay':
        const color = document.createElement('input'); color.type='color'; color.value = e.opts.color || '#000000'; color.oninput = ()=>{ e.opts.color = color.value; };
        const blend = document.createElement('select'); ['normal','multiply','screen','overlay','color-dodge','linear-light','difference','hue','exclusion','negation'].forEach(b=>{ const o=document.createElement('option'); o.value=b; o.textContent=b; blend.appendChild(o); }); blend.value=e.opts.blend||'normal'; blend.onchange=()=>{ e.opts.blend = blend.value; };
        const alpha = document.createElement('input'); alpha.type='range'; alpha.min=0; alpha.max=1; alpha.step=0.01; alpha.value=e.opts.alpha||1; alpha.oninput=()=>{ e.opts.alpha = parseFloat(alpha.value); };
        form.appendChild(document.createTextNode('Color: ')); form.appendChild(color); form.appendChild(document.createElement('br'));
        form.appendChild(document.createTextNode('Blend: ')); form.appendChild(blend); form.appendChild(document.createElement('br'));
        form.appendChild(document.createTextNode('Alpha: ')); form.appendChild(alpha);
        break;
      case 'fisheye':
        addRange('strength',-20,20,0.1); break;
      case 'kaleido':
        addNumber('slices',1,40,1); addRange('angle',0,360,1); addRange('centerX',-9999,9999,1); addRange('centerY',-9999,9999,1);
        const mcb = document.createElement('input'); mcb.type='checkbox'; mcb.checked = !!e.opts.mirror; mcb.onchange=()=>{ e.opts.mirror = mcb.checked; };
        form.appendChild(document.createElement('br')); form.appendChild(document.createTextNode('Mirror: ')); form.appendChild(mcb);
        break;
      case 'mirror': addRange('angle',0,360,1); addRange('centerX',-9999,9999,1); addRange('centerY',-9999,9999,1); break;
      case 'swirl': addRange('angle',-360,360,1); addRange('centerX',-9999,9999,1); addRange('centerY',-9999,9999,1); break;
      case 'waves': addRange('horizontal',0,20,1); addRange('ampH',0,6.284,0.001); addRange('vertical',0,20,1); addRange('ampV',0,6.284,0.001); break;
    }

    const save = document.createElement('button'); save.textContent='Save'; save.onclick=()=>{ modal.remove(); renderStackUI(); };
    const cancel = document.createElement('button'); cancel.textContent='Cancel'; cancel.onclick=()=>{ modal.remove(); };
    modal.appendChild(form); modal.appendChild(save); modal.appendChild(cancel);
    // insert editor at top of stack list
    stackEl.prepend(modal);
  }

  // ====== Effect implementations ======
  // We'll implement by reading baseImageData and applying effects in sequence to a working imageData

  function runStackFast(){
    if(!baseImageData) return;
    // simple fast preview: apply only color-space and simple pixel ops (skip heavy mapping effects)
    const w = baseImageData.width, h = baseImageData.height;
    let working = new ImageData(new Uint8ClampedArray(baseImageData.data), w, h);
    for(const e of effectStack){
      if(['fisheye','kaleido','swirl','waves','mirror'].includes(e.type)) continue; // skip heavy in preview
      working = applyEffectToImageData(working, e);
    }
    ctx.putImageData(working,0,0);
  }

  applyBtn.onclick = ()=>{ applyFullStack(); };
  previewBtn.onclick = ()=>{ runStackFast(); };

  function applyFullStack(){
    if(!baseImageData) return;
    let working = new ImageData(new Uint8ClampedArray(baseImageData.data), baseImageData.width, baseImageData.height);
    for(const e of effectStack){
      if(['fisheye','kaleido','swirl','waves','mirror'].includes(e.type)){
        working = applyMappingEffect(working, e);
      } else {
        working = applyEffectToImageData(working, e);
      }
    }
    ctx.putImageData(working,0,0);
  }

  function applyEffectToImageData(srcImgData, effect){
    const w = srcImgData.width, h=srcImgData.height;
    const dst = new ImageData(w,h);
    const s = srcImgData.data, d = dst.data;
    if(effect.type === 'channel'){
      const rM=effect.opts.r,gM=effect.opts.g,bM=effect.opts.b,aM=effect.opts.a;
      for(let i=0;i<s.length;i+=4){
        const r=s[i], g=s[i+1], b=s[i+2], a=s[i+3];
        d[i] = clamp(r*rM,0,255);
        d[i+1] = clamp(g*gM,0,255);
        d[i+2] = clamp(b*bM,0,255);
        d[i+3] = clamp(a*aM,0,255);
      }
    } else if(effect.type === 'hsl'){
      for(let i=0;i<s.length;i+=4){
        let r=s[i]/255, g=s[i+1]/255, b=s[i+2]/255;
        // RGB->HSL, adjust, HSL->RGB
        const max = Math.max(r,g,b), min=Math.min(r,g,b);
        let h=Math.atan2(Math.sqrt(3)*(g-b),2*r-g-b) * 180/Math.PI; // approx
        let l=(max+min)/2; let S=0; if(max!==min){ S=(l<0.5)?(max-min)/(max+min):(max-min)/(2-max-min);} h = h + (effect.opts.h||0);
        S = S + (effect.opts.s||0)/100; l = l + (effect.opts.l||0);
        // naive HSL->RGB
        function hue2rgb(p,q,t){ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p; }
        let r2,g2,b2;
        if(S===0){ r2=g2=b2=l; } else {
          const q = l<0.5?l*(1+S):l+S-l*S; const p = 2*l-q; const hk = (h%360)/360; r2 = hue2rgb(p,q,hk+1/3); g2 = hue2rgb(p,q,hk); b2 = hue2rgb(p,q,hk-1/3);
        }
        d[i]=clamp(Math.round(r2*255),0,255); d[i+1]=clamp(Math.round(g2*255),0,255); d[i+2]=clamp(Math.round(b2*255),0,255); d[i+3]=s[i+3];
      }
    } else if(effect.type === 'lab'){
      // approximate by converting to L*a*b-ish via linear transform on RGB (not color-accurate)
      for(let i=0;i<s.length;i+=4){
        const R=s[i]/255, G=s[i+1]/255, B=s[i+2]/255;
        // grayscale lightness
        let L = 0.2126*R + 0.7152*G + 0.0722*B;
        L = L + (effect.opts.L||0)/100; // small tweak
        let a = (R - G); let b = (G - B);
        a = a + (effect.opts.a||0); b = b + (effect.opts.b||0);
        // map back roughly
        let r = L + a*0.5; let g = L - (a*0.25) + (b*0.25); let bl = L - b*0.5;
        d[i]=clamp(Math.round(r*255),0,255); d[i+1]=clamp(Math.round(g*255),0,255); d[i+2]=clamp(Math.round(bl*255),0,255); d[i+3]=s[i+3];
      }
    } else if(effect.type === 'invert'){
      if(!effect.opts.enabled) return srcImgData;
      for(let i=0;i<s.length;i+=4){
        // invert luminosity while keeping chroma roughly
        const r=s[i],g=s[i+1],b=s[i+2];
        const lum = 0.299*r + 0.587*g + 0.114*b;
        const inv = 255 - lum;
        const ratio = inv / Math.max(1,lum);
        d[i]=clamp(r*ratio,0,255); d[i+1]=clamp(g*ratio,0,255); d[i+2]=clamp(b*ratio,0,255); d[i+3]=s[i+3];
      }
    } else if(effect.type === 'overlay'){
      const hex = (effect.opts.color||'#000000').replace('#','');
      const r2 = parseInt(hex.substring(0,2),16), g2 = parseInt(hex.substring(2,4),16), b2 = parseInt(hex.substring(4,6),16);
      const a2 = effect.opts.alpha ?? 1;
      const blend = effect.opts.blend || 'normal';
      for(let i=0;i<s.length;i+=4){
        const r=s[i], g=s[i+1], b=s[i+2];
        let nr=r, ng=g, nb=b;
        if(blend==='normal'){
          nr = r*(1-a2) + r2*a2; ng = g*(1-a2) + g2*a2; nb = b*(1-a2) + b2*a2;
        } else if(blend==='multiply'){
          nr = (r*r2/255)*(a2) + r*(1-a2);
          ng = (g*g2/255)*(a2) + g*(1-a2);
          nb = (b*b2/255)*(a2) + b*(1-a2);
        } else if(blend==='screen'){
          nr = (255 - (255-r)*(255-r2)/255)*a2 + r*(1-a2);
          ng = (255 - (255-g)*(255-g2)/255)*a2 + g*(1-a2);
          nb = (255 - (255-b)*(255-b2)/255)*a2 + b*(1-a2);
        } else if(blend==='difference'){
          nr = Math.abs(r - r2)*a2 + r*(1-a2);
          ng = Math.abs(g - g2)*a2 + g*(1-a2);
          nb = Math.abs(b - b2)*a2 + b*(1-a2);
        } else {
          // fallback normal
          nr = r*(1-a2) + r2*a2; ng = g*(1-a2) + g2*a2; nb = b*(1-a2) + b2*a2;
        }
        d[i]=clamp(Math.round(nr),0,255); d[i+1]=clamp(Math.round(ng),0,255); d[i+2]=clamp(Math.round(nb),0,255); d[i+3]=s[i+3];
      }
    } else {
      // default pass-through
      d.set(s);
    }
    return dst;
  }

  // mapping effects (per-pixel sampling with coordinate transforms)
  function applyMappingEffect(srcImgData, effect){
    const w = srcImgData.width, h = srcImgData.height;
    const dst = new ImageData(w,h);
    const s = srcImgData.data, d = dst.data;

    function sampleNearest(x,y){
      const ix = Math.round(x); const iy = Math.round(y);
      if(ix<0||iy<0||ix>=w||iy>=h) return [0,0,0,0];
      const idx = (iy*w + ix)*4; return [s[idx], s[idx+1], s[idx+2], s[idx+3]];
    }

    const cx = (effect.opts.centerX ?? 0.5) * w;
    const cy = (effect.opts.centerY ?? 0.5) * h;

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let sx=x, sy=y;
        const dx = x - cx, dy = y - cy;
        const r = Math.sqrt(dx*dx + dy*dy);
        const theta = Math.atan2(dy, dx);
        if(effect.type === 'fisheye'){
          const sAmt = (effect.opts.strength||0)/100;
          const nr = r * (1 + sAmt * (r / Math.max(w,h)));
          sx = cx + nr * Math.cos(theta); sy = cy + nr * Math.sin(theta);
        } else if(effect.type === 'swirl'){
          const ang = (effect.opts.angle||0) * Math.PI/180;
          const t = 1 - (r / Math.max(w,h));
          const a = ang * t;
          const nx = Math.cos(a)*dx - Math.sin(a)*dy;
          const ny = Math.sin(a)*dx + Math.cos(a)*dy;
          sx = cx + nx; sy = cy + ny;
        } else if(effect.type === 'kaleido'){
          const slices = Math.max(1,Math.floor(effect.opts.slices||6));
          const ang = (effect.opts.angle||0) * Math.PI/180;
          let a = Math.atan2(dy,dx) - ang;
          const seg = (2*Math.PI)/slices;
          a = ((a + Math.PI) % seg) - seg/2;
          if(effect.opts.mirror) a = Math.abs(a);
          const nr = r;
          sx = cx + nr * Math.cos(a + ang);
          sy = cy + nr * Math.sin(a + ang);
        } else if(effect.type === 'mirror'){
          const ang = ((effect.opts.angle||0) * Math.PI/180);
          // reflect across line through center with angle ang
          const nx = dx*Math.cos(ang) + dy*Math.sin(ang);
          const ny = -dx*Math.sin(ang) + dy*Math.cos(ang);
          const rx = -nx; // reflect x
          const rx2 = rx*Math.cos(ang) - ny*Math.sin(ang);
          const ry2 = rx*Math.sin(ang) + ny*Math.cos(ang);
          sx = cx + rx2; sy = cy + ry2;
        } else if(effect.type === 'waves'){
          const hCount = effect.opts.horizontal||0; const ampH = effect.opts.ampH||0;
          const vCount = effect.opts.vertical||0; const ampV = effect.opts.ampV||0;
          sx = x + Math.sin((y / h) * hCount * 2*Math.PI) * ampH * w;
          sy = y + Math.sin((x / w) * vCount * 2*Math.PI) * ampV * h;
        }
        const col = sampleNearest(sx, sy);
        const idx = (y*w + x)*4;
        d[idx]=col[0]; d[idx+1]=col[1]; d[idx+2]=col[2]; d[idx+3]=col[3];
      }
    }
    return dst;
  }

  // helper: apply an effect to the current canvas image (not used in stack)
  function applyEffectNow(effect){
    const id = ctx.getImageData(0,0,canvas.width,canvas.height);
    const out = applyEffectToImageData(id, effect);
    ctx.putImageData(out,0,0);
  }

  // initial empty UI
  renderStackUI();

  // keyboard shortcuts for convenience
  window.addEventListener('keydown',(e)=>{
    if(e.key===' '){ e.preventDefault(); runStackFast(); }
    if(e.key==='Enter'){ applyFullStack(); }
  });
  </script>
</body>
</html>
